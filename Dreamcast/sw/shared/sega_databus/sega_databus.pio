.program sega_cs_detect
set pindirs, 1
.wrap_target
	wait 0 gpio 4
	;; there seems to be 4 cycles of latency between the pin going low and the gpio going high
	;; This is even with the input synchronizers disabled
	;; Additionally using `wait pin` instead of `wait gpio` adds another cycle of latency
	set pins, 1 [3]
	set pins, 0

	wait 1 gpio 4
.wrap

; ; .define sega_cs0 3
; .program sega_cs0_detect
; .wrap_target
; cs0_detect:
; 	wait 0 gpio 3
; 	irq 4
; 	wait 1 gpio 3
; .wrap

; ; .define sega_cs1 4
; .program sega_cs1_detect
; .wrap_target
; 	wait 0 gpio 4
; 	irq 4
; 	wait 1 gpio 4
; .wrap

; ; .define RD 16
; .program sega_read_detect
; .wrap_target
; 	wait 0 gpio 16
; 	irq 5
; 	wait 1 gpio 16
; .wrap

; ; .define WR 17
; .program sega_write_detect
; .wrap_target
; 	wait 0 gpio 17
; 	irq 5
; 	wait 1 gpio 17
; .wrap

;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Combined programs ;;;

;; CS0 and Read combined
; .define sega_cs0(gpio 3) and RD (gpio 16) detect
.program sega_cs0_read_detect
.wrap_target
cs0_detect:
	wait 0 gpio 3
	irq 4
	wait 1 gpio 3
.wrap

read_detect:
	wait 0 gpio 16
	irq 5
	wait 1 gpio 16
	jmp read_detect

;; CS1 and Write combineid
; .define sega_cs1(gpio 4) and WR (gpio 17) detect
.program sega_cs1_write_detect
.wrap_target
cs1_detect:
	wait 0 gpio 4
	irq 4
	wait 1 gpio 4
.wrap

write_detect:
	wait 0 gpio 17
	irq 5
	wait 1 gpio 17
	jmp write_detect





.program sega_cs_rw_detect
.wrap_target
	set y, 2
cs_detect:
	; sample both cs lines
	in NULL, 32 ;; 0 out the isr
	in pins, 2 ; in pins should be gpio 3,4
	mov x, isr ; put the 2 bits into the x register to compare
	
	;; Check that cs lines are not both 0 or 1
	jmp x--, x_check ;; x>0 and then x--
	jmp cs_detect ;; else x IS 0 then we just restart

x_check:
	jmp !x, set_cs_irq ;;if x == 0 which means x was 1, the only valid case, jmp to set irq
	jmp cs_detect ;; else restart waiting for signal

set_cs_irq:
	irq 4

wait_for_both_cs_high:
	in NULL, 32 ;; 0 out the isr
	in pins, 2
	mov x, isr
	jmp x!=y, wait_for_both_cs_high
.wrap


;;;;;;; Experimental Combined program WIP ;;;;;;;;
;; CS0 and Read combined
;; Start in pins at gpio 3(cs0) and go to gpio 17(write)
;; We can dump extra bit we don't want
; .program sega_cs_rw_detect
; .wrap_target
; 	set y, 2
; cs_detect:
; 	; sample both cs lines
; 	set x, 0 ; clear x
; 	in pins, 2 ; in pins should be gpio 3,4
; 	mov x, isr ; put the 2 bits into the x register to compare
	
; 	;; Check that cs lines are not both 0 or 1
; 	jmp x--, x_check ;; x>0 and then x--
; 	jmp cs_detect ;; else x IS 0 then we just restart

; x_check:
; 	jmp !x, set_cs_irq ;;if x == 0 which means x was 1, the only valid case, jmp to set irq
; 	jmp cs_detect ;; else restart waiting for signal

; set_cs_irq:
; 	; if sample is 1 or 0 then we send irq
; 	irq 4


; Just check for CS pins for now	
; rw_detect:
;     mov osr, pins ; Read all pins into OSR
;     out null, 13 ; Dump 13 bits of OSR contents to get to gpio 16, 17
; 	mov x, osr

; 	;; Check that r/w lines are not both 0 or 1
; 	jmp x--, x_rw_check ;; x>0 and then x--
; 	jmp rw_detect ;; else x IS 0 then we just restart and keep waiting for r/w line to go low

; x_rw_check:
; 	jmp !x, set_rw_irq ;;if x == 0 which means x was 1, the only valid case, jmp to set irq
; 	jmp cs_detect ;; else restart waiting for signal

; set_rw_irq:
; 	irq 5

; wait_for_both_cs_high:
; 	set x, 0 ; clear x
; 	in pins, 2
; 	mov x, isr
; 	jmp x!=y, wait_for_both_cs_high
; .wrap

;;; END combined programs ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.program sega_databus_handler
.side_set 1 opt
.wrap_target
wait_for_cs:
	;; change pindirs to input
	;; only pins setup in sm_config_set_out pin are affected
	mov osr, null
    out pindirs, 32 side 1 ;; also set MUX to control lines | HIGH for control lines

	wait 1 irq 4 ;; wait for CS lines

	in pins, 5
	push ;;side 0 ;; push data and also set mux to data pins | LOW for data lines

;; debug jmp to ignore the rest of the program
jmp wait_for_cs


	;; wait for read/write pio programs to detect a low signal
	wait 1 irq 5

	in pins, 18 side 0 ;; read in all the data pins, read and write THEN change MUX to data lines | LOW for data lines
	;; this gives us the control lines, read, and write values
	;; C code can mask to get whatever info it needs
	push ;; send values to C

	;; The READ pin is assigned to the JMP pin so we can jmp to write if READ is high (WRITE is low)
; 	jmp pin write_to_bus

; ;; WRITE low, read the pins and write to a register.
; read_from_bus:
; 	in pins, 16
; 	push
; 	jmp wait_for_cs

; ;; READ low, means we put data on lines from a register
; write_to_bus:
; 	;; Change pins to output
; 	mov osr, ~null
;     out pindirs, 32 ;; only pins setup in sm_config_set_out pin are affected

; 	;; Put data from C on pins
; 	pull
; 	out pins, 16

.wrap